#!/bin/sh
#
# The eps2pdf script uses ghostscript to convert eps files to pdf.
#
# Wouter Kager

program=`basename $0`
version=2008/06/01
gsopts="-q -dSAFER -dNOPAUSE -dBATCH -dPDFSETTINGS=/prepress"
force=n
dres=
fixbb=n
model=
quality=
angle=0
xscale=1
yscale=1
width=
height=

echo "$program $version by Wouter Kager"
echo

# Scan command line options.
while getopts :Bd:fh:j:m:r:s:w: optionkey $*; do
	case $optionkey in
		B)	fixbb=y ;;
		d)	dres=$OPTARG ;;
		f)	force=y ;;
		h)	height=`echo "$OPTARG" | sed 's/[0-9\.]*/& /'` ;;
		j)	quality=`expr 100 - $OPTARG` ;;
		m)	if [ $OPTARG != CMYK -a $OPTARG != RGB -a $OPTARG != Gray ]; then
				echo "$program: invalid color model requested!"
				echo "$program: run $program without arguments for help"
				exit 1
			fi
			model="-dProcessColorModel=/Device$OPTARG" ;;
		r)	angle=$OPTARG ;;
		s)	xscale=`echo $OPTARG,$OPTARG | cut -d , -f 1`
			yscale=`echo $OPTARG,$OPTARG | cut -d , -f 2` ;;
		w)	width=`echo "$OPTARG" | sed 's/[0-9\.]*/& /'` ;;
		:)	echo "$program: the option -$OPTARG requires an argument!"
			echo "$program: run $program without arguments for help"
			exit 1 ;;
		?)	echo "$program: the option -$OPTARG is illegal!"
			echo "$program: run $program without arguments for help"
			exit 1 ;;
	esac
done

shift `expr $OPTIND - 1`

# Check if we have received any input files.
if [ ${#} -eq 0 ]; then
	cat <<-EOF
		Usage: $program [options] file(s)
		
		The valid options are:
		 -B           use ghostscript to correct the Bounding Box
		 -d res       set distiller / resampling resolution (dpi)
		 -f           force files to be overwritten if they exist
		 -h height    scale image to desired height (in cm/mm/in)
		 -j quality   use jpeg compression, quality from 1 to 100
		 -m model     set color model to either RGB, CMYK or Gray
		 -r angle     rotate counter-clockwise by angle (degrees)
		 -s scale     scale image by the requested scaling factor
		 -s xs,ys     sets horizontal,vertical scaling separately
		 -w width     scale image to specific width (in cm/mm/in)
		EOF
	exit 0
fi

#--------------------------- Function definitions ---------------------------

# find_bbox scans the file $1 for the bounding box.
find_bbox ()
{
	if [ $fixbb = y ]; then
		# we try to capture parts of the image at negative coordinates too.
		set -- `gs $gsopts -sDEVICE=bbox -c "800 800 translate" -f "$1" 2>&1 |
			awk '/HiRes/ { print $4-($2),$5-($3),$2-800,$3-800 }'`
	else
		# tr creates UNIX files from DOS or MAC files by translating CR to NL,
		# and awk selects either the first or the last (atend) %%BoundingBox
		# line for the coordinates. 
		set -- `cat "$1" | tr -s "\r" "\n" | sed -n 's/^%%BoundingBox: //p' |
			awk 'BEGIN {w=0; h=0; x=0; y=0}
			/-?[0-9]+ -?[0-9]+ -?[0-9]+ -?[0-9]+/ {
				w=$3-($1); h=$4-($2); x=$1; y=$2; if (NR==1) {exit}}
			END {print w,h,x,y}'`
	fi

	wd=$1; ht=$2; bx=$3; by=$4
}

# set_rscode sets the rotation and scaling code.
set_rscode ()
{
	rscode="/in {72 mul} def /cm {2.54 div in} def /mm {25.4 div in} def"

	if [ -n "$width" ]; then
		rscode="$rscode $width $wd div"
		if [ -n "$height" ]; then rscode="$rscode $height $ht div";
		else rscode="$rscode dup"; fi
	else
		if [ -n "$height" ]; then rscode="$rscode $height $ht div dup";
		else rscode="$rscode $xscale $yscale"; fi
	fi

	rscode="$rscode 2 copy exch $wd mul exch $ht mul add dup translate"
	rscode="$rscode $angle rotate scale $bx neg $by neg translate"
}

# new_bbox computes the new bbox after rotation and scaling.
new_bbox ()
{
	set -- `gs $gsopts -sDEVICE=bbox -c "$rscode" -f "$1" 2>&1 |
			awk '/HiRes/ { print $4-($2),$5-($3),$2,$3 }'`

	nwd=$1; nht=$2; nx=$3; ny=$4
}

# set_dp sets the distiller compression and resampling parameters.
set_dp ()
{
	gsres=
	dp="systemdict /setdistillerparams known { <<"
	dp="$dp /EmbedAllFonts true /SubsetFonts true"
	dp="$dp /AutoFilterColorImages false /AntiAliasColorImages true"
	dp="$dp /AutoFilterGrayImages false /AntiAliasGrayImages true"

	if [ -n "$quality" ]; then
		dp="$dp /ColorImageFilter /DCTEncode /GrayImageFilter /DCTEncode"
		dp="$dp /ColorImageDict << /QFactor 0.$quality /ColorTransform 1"
		dp="$dp /Blend 1 /HSamples [1 1 1 1] /VSamples [1 1 1 1] >>"
		dp="$dp /GrayImageDict << /QFactor 0.$quality /ColorTransform 1"
		dp="$dp /Blend 1 /HSamples [1 1 1 1] /VSamples [1 1 1 1] >>"
	else
		dp="$dp /ColorImageFilter /FlateEncode /GrayImageFilter /FlateEncode"
	fi

	if [ -n "$dres" ]; then
		dp="$dp /DownsampleColorImages true"
		dp="$dp /ColorImageDownsampleThreshold 1.0 /ColorImageResolution $dres"
		dp="$dp /DownsampleGrayImages true"
		dp="$dp /GrayImageDownsampleThreshold 1.0 /GrayImageResolution $dres"
		gsres="-r$dres"
	fi

	dp="$dp >> setdistillerparams } if"
}

# distill uses gs to convert $1 to $base.pdf.
distill ()
{
	if [ -n "$width$height" -o $xscale$yscale != 11 -o $angle != 0 ]; then
		set_rscode
		new_bbox "$1"
		gs -sDEVICE=pdfwrite -sOutputFile="$base.pdf" $gsopts $model $gsres \
		-c "$dp" -c "<< /PageSize [$nwd $nht] >> setpagedevice" \
		-c "$nx neg $ny neg translate $rscode" -f "$1" -c quit > $tmp.log 2>&1
	else
		gs -sDEVICE=pdfwrite -sOutputFile="$base.pdf" $gsopts $model $gsres \
		-c "$dp" -c "<< /PageSize [$wd $ht] >> setpagedevice" \
		-c "$bx neg $by neg translate" -f "$1" -c quit > $tmp.log 2>&1
	fi
}

# show_error reports errors after running $1.
show_error ()
{
	echo [error]
	echo "$program: $1 reported the following errors:"
	echo
	cat $tmp.log
}

# ------------------------ End of function definitions ----------------------

tmp=$program$$
OK=y

# Make sure existing files are only overwritten if the user agrees.
if [ -w $tmp.log -a $force = n ]; then
	echo "$program: warning, the file $tmp.log exists!"
	printf "$program: should I overwrite it (y/n)? "
	read OK

	if [ "$OK" != y ]; then
		echo "$program: in that case, I can't proceed"
		exit 0
	fi
fi

# Set the distiller parameters.
set_dp

# Loop through all files specified on the command line.
for file
do

echo
base=`echo "$file" | sed 's/\.eps$//'`

# See if the input file is there.
if [ ! -f "$base.eps" ]; then
	echo "$program: file $base.eps: no such file (skipping)"
	continue
fi
if [ ! -r "$base.eps" ]; then
	echo "$program: file $base.eps: not readable (skipping)"
	continue
fi

echo "$program: processing file $base.eps"

# Find bounding box.
find_bbox "$base.eps"
if [ $wd = 0 -o $ht = 0 ]; then
	echo "$program: no bounding box found (skipping)"
	continue
fi

# Only overwrite existing pdf file if the user agrees.
if [ -w "$base.pdf" -a $force = n ]; then
	echo "$program: warning, the file $base.pdf exists!"
	printf "$program: should I overwrite it (y/n)? "
	read OK
fi

# Perform the conversion or skip the file.
if [ "$OK" = y ]; then
	printf "$program: $base.eps -> $base.pdf "

	distill "$base.eps"
	if [ $? -ne 0 ]; then show_error "gs distiller"; continue; fi

	echo [ok]
else
	echo "$program: file $base.eps skipped [ok]"
fi

done

# Clean up.
rm -f $tmp.log
