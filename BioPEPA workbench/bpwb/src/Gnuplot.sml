(* File: Gnuplot.sml

   Format parameters for Gnuplot
*)

structure Gnuplot :> Gnuplot =
struct

   val solver = ref "stochkit"
   val iterations = ref 1
   val thisIteration = ref 0
   val parameters = ref [ "parameters not set" ]
   val genfiles = ref [] : string list ref
   val modeldefs = ref [] : (string * string) list ref

   fun setModelDefs m = modeldefs := m

   fun stripChar #" " = "" | stripChar c = str c
   fun stripSpaces s = String.translate stripChar s

   fun lookupBool s = 
       stripSpaces(Configuration.lookup s) = "true"
   fun lookup s = Configuration.lookup("gnuplot." ^ s)
   fun lookups s = stripSpaces (lookup s)

   fun escapeQuotes #"\"" = "\\\"" | escapeQuotes c = str c
   fun lookupQ s = String.translate escapeQuotes (lookup s)

   fun lookupq s = "\"" ^ lookup s ^ "\""

   fun formatHeader s = 
     "# Gnuplot script generated by the BioPEPA Workbench\n\n" ^
     "set terminal " ^ lookup("terminal") ^ "\n" ^ 
     "set output \"" ^ s ^ "." ^ lookups("file.extension") ^ "\"\n" ^ 
     "set xlabel " ^ lookupq("xlabel") ^ "\n" ^ 
     "set ylabel " ^ lookupq("ylabel") ^ "\n" ^
     "set key " ^ lookup("key.position") ^ "\n" 

   fun isSpecies p = Char.isUpper (List.hd (explode p))
   fun keepSpecies [] = []
     | keepSpecies ((p, _)::t) = 
          if isSpecies p then p :: keepSpecies t else keepSpecies t
   fun getSpecies p = 
       if !solver = "dizzy" 
       then Sort.quicksort(keepSpecies p) 
       else keepSpecies p
   fun quote s = "\"" ^ s ^ ".dat\""
   fun format1 s n h = 
       let val n = (Species.lookup h) + 2
        in
         "    " ^ quote s ^ " using 1:" ^ Int.toString n ^ 
         " " ^ lookup("points") ^ 
         " " ^ (if !thisIteration = 0
                then lookup("linestyle.0")
                else lookup("linestyle")) ^ 
         " title \"" ^ h ^ "\""
        end

   fun format1ModelDef s m def = 
       "    " ^ quote s ^ " using 1:" ^ Model.toGnuplotString def ^ 
       " " ^ lookup("points") ^ 
       " " ^ (if !thisIteration = 0
              then lookup("linestyle.0")
              else lookup("linestyle")) ^ 
       " title \"" ^ m ^ "\""

   local
     fun formatModelDefs s [] = ""
       | formatModelDefs s [(m, def)] = 
         format1ModelDef s m def
       | formatModelDefs s ((m, def)::t) =
         format1ModelDef s m def ^ ", " ^
         formatModelDefs s t
         
     fun format s _ [] =
         if !modeldefs = [] then ""
         else ", " ^ formatModelDefs s (!modeldefs)
       | format s n [x] = 
         format1 s n x ^ 
           (if !modeldefs = [] then ""
            else ", " ^ formatModelDefs s (!modeldefs))
       | format s n (h::t) = format1 s n h ^ ", " ^ format s (n+1) t
   in 
     fun formatParameters jobname parameters = 
       "plot " ^ format jobname 2 (getSpecies parameters)
   end

   local
     fun mem x [] = false
       | mem x (h::t) = x=h orelse mem x t
     fun formatF f s n x = 
         if mem x f then format1 s n x else ""
     fun format  _ _ _ [] = ""
       | format f s n [x] = formatF f s n x
       | format f s n (h::t) = 
         let val front =  formatF f s n h 
             val back = format f s (n+1) t
          in if front = "" then back
             else if back = "" then front
                  else back ^ ", " ^ front
         end
   in 
     fun formatParametersFiltered jobname parameters filter = 
       "plot " ^ format filter jobname 2 (getSpecies parameters)
   end

   fun generate1 (modelName, parameters, filter) =
       let val plotparameters = PlotFile.getParameters() 
           val root = modelName ^ "_" ^ !solver ^ "_results_" ^ Int.toString(!thisIteration)
           val _ = genfiles := root :: !genfiles
        in 
           if plotparameters = [] 
           then let 
                    val gnuplot = TextIO.openOut (root ^ ".gnu") 
                 in 
                    TextIO.output(gnuplot, formatHeader(root)^"\n");
                    TextIO.output(gnuplot, 
                                  formatParameters(root)(parameters)^"\n");
                    TextIO.closeOut gnuplot
                end 
           else let val plotfile = TextIO.openOut (root ^ "_plot.gnu") 
                 in
                    TextIO.output(plotfile, formatHeader(root)^"\n");
                    TextIO.output(plotfile,
                                  formatParametersFiltered(root)
                                          (parameters)(plotparameters)^"\n");
                    TextIO.closeOut plotfile
                end
      end;

   fun generate (modelName, parameters) =
       let val repString = Configuration.lookup("biopepa.independent.replications")
           val reps = Int.fromString(repString)
        in case reps of 
             SOME i => iterations := i
           | NONE => Error.fatal_error("Could not interpret biopepa.independent.replications of \"" ^ repString ^ "\"");
           solver := stripSpaces(Configuration.lookup("biopepa.simulator"));
	   thisIteration := 0;
           if lookupBool("biopepa.show.all.replications")
           then () else iterations := 0;
           while(!thisIteration <= !iterations) do (
               generate1(modelName, parameters, PlotFile.getParameters());
               thisIteration := !thisIteration + 1
           )
       end handle _ => Error.fatal_error("GNUplot generation")

   fun generated () = List.rev(!genfiles)
end;
